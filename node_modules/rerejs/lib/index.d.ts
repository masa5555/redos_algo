/** `CharSet` is a set of code points. */
declare class CharSet {
    /**
     * Internal data of this.
     *
     * This is a sorted number array.
     * An odd element is begin of a range, and an even element is end of a range.
     * So, this array's size must be even always.
     *
     * ```typescript
     * const set = new CharSet();
     * set.add(10, 20);
     * set.add(30, 40)
     * console.log(set.data);
     * // => [10, 20, 30, 40]
     * ```
     */
    data: number[];
    constructor(data?: number[]);
    /** Add a range to this. */
    add(begin: number, end?: number): void;
    /** Add another `CharSet` to this. */
    addCharSet(set: CharSet): void;
    /**
     * Invert this set.
     *
     * Note that this method is mutable like `Array.prototype.reverse`.
     * Please clone before this if immutable is desired.
     */
    invert(): CharSet;
    /** Clone this set. */
    clone(): CharSet;
    /** Check is a code point contained in this set. */
    has(c: number): boolean;
    /** Convert this into `RegExp` char-class pattern string. */
    toRegExpPattern(invert?: boolean): string;
    toString(): string;
    /** Find the least `i` such that satisfy `c <= this.data[i * 2 + 1]`. */
    private searchBegin;
    /** Find the maximum `j` such that satisfy `this.ranges[j * 2] <= c`. */
    private searchEnd;
}
//# sourceMappingURL=char-set.d.ts.map

/** Type for whole regular expression pattern. */
declare type Pattern = {
    type: 'Pattern';
    flagSet: FlagSet;
    captureParens: number;
    names: Map<string, number>;
    child: Node;
    range: [number, number];
};
/** Types for regular expression flags. */
declare type FlagSet = {
    global: boolean;
    ignoreCase: boolean;
    multiline: boolean;
    dotAll: boolean;
    unicode: boolean;
    sticky: boolean;
};
/** Type for part of regular expression pattern. */
declare type Node = Disjunction | Sequence | Capture | NamedCapture | Group | Many | Some | Optional | Repeat | WordBoundary | LineBegin | LineEnd | LookAhead | LookBehind | Char | EscapeClass | Class | Dot | BackRef | NamedBackRef;
/** Type for items of character class. */
declare type ClassItem = Char | EscapeClass | ClassRange;
/** Type for AST elements. */
declare type Element = Pattern | Node | ClassItem;
/** Type for select pattern `/(a|b)/`. */
declare type Disjunction = {
    type: 'Disjunction';
    children: Node[];
    range: [number, number];
};
/** Type for sequence pattern `/(ab)/`. */
declare type Sequence = {
    type: 'Sequence';
    children: Node[];
    range: [number, number];
};
/** Type for capture group `/(...)/`. */
declare type Capture = {
    type: 'Capture';
    index: number;
    child: Node;
    range: [number, number];
};
/** Type for named capture group `/(?<x>...)/`. */
declare type NamedCapture = {
    type: 'NamedCapture';
    name: string;
    raw: string;
    child: Node;
    range: [number, number];
};
/** Type for non-capture group `/(?:...)/`. */
declare type Group = {
    type: 'Group';
    child: Node;
    range: [number, number];
};
/** Type for zero-or-more repetition pattern `/(a*)/`. */
declare type Many = {
    type: 'Many';
    nonGreedy: boolean;
    child: Node;
    range: [number, number];
};
/** Type for one-or-more repetition pattern `/(a+)/`. */
declare type Some = {
    type: 'Some';
    nonGreedy: boolean;
    child: Node;
    range: [number, number];
};
/** Type for skippable pattern `/(a?)/`. */
declare type Optional = {
    type: 'Optional';
    nonGreedy: boolean;
    child: Node;
    range: [number, number];
};
/** Type for general repetition pattern `/(a{10,20})/`. */
declare type Repeat = {
    type: 'Repeat';
    min: number;
    max: number | null;
    nonGreedy: boolean;
    child: Node;
    range: [number, number];
};
/** Type for word boundary assertion pattern `/(\b)/`. */
declare type WordBoundary = {
    type: 'WordBoundary';
    invert: boolean;
    range: [number, number];
};
/** Type for line begin assertion pattern `/(^)/`. */
declare type LineBegin = {
    type: 'LineBegin';
    range: [number, number];
};
/** Type for line end assertion pattern `/($)/`. */
declare type LineEnd = {
    type: 'LineEnd';
    range: [number, number];
};
/** Type for look-ahead assertion `/(?=a)/`. */
declare type LookAhead = {
    type: 'LookAhead';
    negative: boolean;
    child: Node;
    range: [number, number];
};
/** Type for look-behind assertion `/(?<=a)/`. */
declare type LookBehind = {
    type: 'LookBehind';
    negative: boolean;
    child: Node;
    range: [number, number];
};
/** Type for character pattern `/a/`. */
declare type Char = {
    type: 'Char';
    value: number;
    raw: string;
    range: [number, number];
};
/** Type for escape sequence class like `/\w/`. */
declare type EscapeClass = SimpleEscapeClass | UnicodePropertyEscapeClass | UnicodePropertyValueEscapeClass;
/** Type for simple escape sequence class like `/\d/`. */
declare type SimpleEscapeClass = {
    type: 'EscapeClass';
    kind: 'digit' | 'word' | 'space';
    invert: boolean;
    range: [number, number];
};
/** Type for unicode property escape sequence class like `\p{Zs}`. */
declare type UnicodePropertyEscapeClass = {
    type: 'EscapeClass';
    kind: 'unicode_property';
    invert: boolean;
    property: string;
    range: [number, number];
};
/** Type for unicode property value escape sequence class like `\p{Script=Hira}`. */
declare type UnicodePropertyValueEscapeClass = {
    type: 'EscapeClass';
    kind: 'unicode_property_value';
    invert: boolean;
    property: string;
    value: string;
    range: [number, number];
};
/** Type for character class pattern `/[a-z]/`. */
declare type Class = {
    type: 'Class';
    invert: boolean;
    children: ClassItem[];
    range: [number, number];
};
/** Type for character range in class pattern. */
declare type ClassRange = {
    type: 'ClassRange';
    children: [Char, Char];
    range: [number, number];
};
/** Type for any character pattern `/./`. */
declare type Dot = {
    type: 'Dot';
    range: [number, number];
};
/** Type for back reference pattern `/\1/`. */
declare type BackRef = {
    type: 'BackRef';
    index: number;
    range: [number, number];
};
/** Type for named back reference pattern `/\k<x>/`. */
declare type NamedBackRef = {
    type: 'NamedBackRef';
    name: string;
    raw: string;
    range: [number, number];
};
/** Show node as string. */
declare const nodeToString: (n: Node) => string;
/** Show flag set as string. */
declare const flagSetToString: (set: FlagSet) => string;
/** Show pattern as string. */
declare const patternToString: (p: Pattern) => string;
//# sourceMappingURL=pattern.d.ts.map

/** `Match` is result data of regular expression pattern matching. */
declare class Match {
    /** An input string of this matching. */
    readonly input: string;
    private readonly caps;
    private readonly names;
    constructor(input: string, caps: number[], names: Map<string, number>);
    /** Return the initial index of this matching. */
    get index(): number;
    /** Return the last index of this matching. */
    get lastIndex(): number;
    /**
     * Return number of capture group.
     *
     * This number contains capture `0` (whole matching) also.
     */
    get length(): number;
    /** Get the capture `k`. */
    get(k: number | string): string | undefined;
    /** Get the begin index of the capture `k`. */
    begin(k: number | string): number | undefined;
    /** Get the end index of the capture `k`. */
    end(k: number | string): number | undefined;
    /**
     * Resolve name to capture index.
     *
     * If not resolved, it returns `-1`.
     */
    private resolve;
    /** Convert this into `RegExp`'s result array. */
    toArray(): RegExpExecArray;
    toString(): string;
}
//# sourceMappingURL=match.d.ts.map

/** `OpCode` is a type of op-codes. */
declare type OpCode = {
    op: 'any';
} | {
    op: 'back';
} | {
    op: 'cap_begin';
    index: number;
} | {
    op: 'cap_end';
    index: number;
} | {
    op: 'cap_reset';
    from: number;
    to: number;
} | {
    op: 'char';
    value: number;
} | {
    op: 'class';
    set: CharSet;
} | {
    op: 'class_not';
    set: CharSet;
} | {
    op: 'dec';
} | {
    op: 'empty_check';
} | {
    op: 'fail';
} | {
    op: 'fork_cont';
    next: number;
} | {
    op: 'fork_next';
    next: number;
} | {
    op: 'jump';
    cont: number;
} | {
    op: 'line_begin';
} | {
    op: 'line_end';
} | {
    op: 'loop';
    cont: number;
} | {
    op: 'match';
} | {
    op: 'pop';
} | {
    op: 'push';
    value: number;
} | {
    op: 'push_pos';
} | {
    op: 'push_proc';
} | {
    op: 'ref';
    index: number;
} | {
    op: 'ref_back';
    index: number;
} | {
    op: 'restore_pos';
} | {
    op: 'rewind_proc';
} | {
    op: 'word_boundary';
} | {
    op: 'word_boundary_not';
};
/** Show op-codes as string. */
declare const codesToString: (codes: OpCode[]) => string;
//# sourceMappingURL=op-code.d.ts.map

/**
 * `Program` is a container of compiled regular expreession.
 *
 * This can execute op-codes on VM also.
 */
declare class Program {
    /** A regular expression pattern. */
    pattern: Pattern;
    /** An array of op-codes compiled `pattern`. */
    codes: OpCode[];
    /** Pre-calculated maximum stack size. */
    private maxStackSize;
    private get ignoreCase();
    private get multiline();
    private get dotAll();
    private get unicode();
    private get sticky();
    private get captureParens();
    private get names();
    constructor(pattern: Pattern, codes: OpCode[]);
    toString(): string;
    exec(input: string, pos?: number): Match | null;
    private createProc;
}
//# sourceMappingURL=program.d.ts.map

/** `Compiler` is a compiler for `Pattern` to `Program`. */
declare class Compiler {
    private pattern;
    private advance;
    private captureParensIndex;
    private direction;
    private get ignoreCase();
    private get unicode();
    private get captureParens();
    private get names();
    constructor(pattern: Pattern);
    /** Run compiler and return compiled `Program`. */
    compile(): Program;
    private compileNode;
    private compileDisjunction;
    private compileSequence;
    private compileGroup;
    private compileCapture;
    private compileNamedCapture;
    private compileMany;
    private compileSome;
    private compileOptional;
    private compileRepeat;
    private insertEmptyCheck;
    private insertCapReset;
    private compileWordBoundary;
    private compileLineBegin;
    private compileLineEnd;
    private compileLookAhead;
    private compileLookBehind;
    private compileLookAround;
    private compileChar;
    private compileEscapeClass;
    private compileClass;
    private escapeClassToSet;
    private compileDot;
    private insertBack;
    private compileBackRef;
    private compileNamedBackRef;
}
//# sourceMappingURL=compiler.d.ts.map

declare const RegExpCompat: RegExpConstructor;
//# sourceMappingURL=regexp-compat.d.ts.map

/**
 * `Parser` is parser for regular expression pattern.
 *
 * This parses ECMA-262 `RegExp` pattern syntax.
 * See https://www.ecma-international.org/ecma-262/10.0/index.html#sec-patterns.
 *
 * Also, "Additional ECMAScript Features for Web Browsers" is supported if `additional` flag is `true` (default).
 * See https://www.ecma-international.org/ecma-262/10.0/index.html#sec-regular-expressions-patterns.
 */
declare class Parser {
    /** The source pattern string to parse. */
    private source;
    /** The flags string. */
    private flags;
    private flagSet;
    /**
     * A flag whether support "Additional ECMAScript Features for Web Browsers" syntax.
     *
     * See https://www.ecma-international.org/ecma-262/10.0/index.html#sec-regular-expressions-patterns.
     */
    private additional;
    /** Precalculated number of capture group parens. */
    private captureParens;
    /** Precalculated `Map` associate from capture group name to its index. */
    private names;
    /** Is the `flagSet` has `unicode`? */
    private get unicode();
    /** The current position of `source` string on parsing. */
    private pos;
    /** The current capture group parens index number. */
    private captureParensIndex;
    constructor(source: string, flags?: string, additional?: boolean);
    /** Run this parser. */
    parse(): Pattern;
    /** Parse flags. */
    private preprocessFlags;
    /**
     * Count number of capture group parens, and collect names.
     *
     * This process is needed before parsing because the syntax changes
     * its behavior when a pattern has named captrue.
     */
    private preprocessCaptures;
    /** Skip character class without parsing. */
    private skipCharClass;
    /**
     * Parse `disjunction` pattern.
     *
     * See https://www.ecma-international.org/ecma-262/10.0/index.html#prod-Disjunction.
     */
    private parseDisjunction;
    /**
     * Parse `sequence` pattern.
     *
     * `sequence` is named `Alternative` in ECMA-262 specification.
     * However this naming is very confusing because
     * it does not make sence without the relation to `Disjunction`.
     * In formal language theory, `sequence` or `concatination` is better.
     *
     * See https://www.ecma-international.org/ecma-262/10.0/index.html#prod-Alternative.
     */
    private parseSequence;
    /**
     * Parse `quantifier` pattern.
     *
     * `quantifier` is one of `*`, `+`, `?` and `{n,m}` suffix operators,
     * and they can follow `?` for non-greedy matching.
     *
     * Note that ECMA-262 specification does not allow to quantify assertions like `/\b/`.
     *
     * See https://www.ecma-international.org/ecma-262/10.0/index.html#prod-Quantifier,
     * and https://www.ecma-international.org/ecma-262/10.0/index.html#prod-Term.
     */
    private parseQuantifier;
    /**
     * Parse simple quantifier suffix.
     *
     * Simple quantifier suffix means quantifiers execpt for `{n,m}`.
     */
    private parseSimpleQuantifier;
    /**
     * Parse repeat quantifier suffix (`{n}`, `{n,m}` or `{n,}`).
     *
     * When parsing is failed, however it is in `additional` mode,
     * it is retryable. And the real parsing is done by
     * `tryParseRepeatQuantifier` method.
     */
    private parseRepeat;
    /**
     * Try to parse repeat quantifier.
     *
     * This method is separated from `parseRepeat` because
     * it is reused by `parseAtom` to detect "nothing to repeat" error
     * of repeat quantifier.
     *
     * When parsing is failed, it does not consume any character and return `null`.
     */
    private tryParseRepeatQuantifier;
    /**
     * Parse `atom` pattern.
     *
     * This method also parses `assertion` pattern.
     *
     * See https://www.ecma-international.org/ecma-262/10.0/index.html#prod-Assertion,
     * and https://www.ecma-international.org/ecma-262/10.0/index.html#prod-Atom.
     */
    private parseAtom;
    /** Parse `character class` pattern. */
    private parseClass;
    /** Parse an item of `character class` pattern. */
    private parseClassItem;
    /** Parse an atom of `character class` range. */
    private parseClassAtom;
    /**
     * Parse `escape sequence` pattern including `escape sequence character class`,
     * `back reference` and `word boundary assertion` patterns.
     */
    private parseEscape;
    /** Try to parse `word boundary` pattern. */
    private tryParseWordBoundary;
    /** Try to parse `back reference` pattern. */
    private tryParseBackRef;
    /** Try to parse `escape sequence` pattern. */
    private tryParseEscape;
    /**
     * Try to parse `\uXXXX` or `\u{XXXXXX}` escape sequence.
     *
     * This method is separated from `tryParseEscape` because
     * it is reused by `parseCaptureNameChar`.
     *
     * When it is failed, it returns `''`.
     */
    private tryParseUnicodeEscape;
    /** Try to parse `escape sequence character class` pattern. */
    private tryParseEscapeClass;
    /** Parse the first component of `\p{XXX=XXX}` escape sequence. */
    private parseUnicodePropertyName;
    /** Parse the second component of `\p{XXX=XXX}` escape sequence. */
    private parseUnicodePropertyValue;
    /** Parse grouping pattern by paren. */
    private parseParen;
    /**
     * Parse capture name.
     *
     * This method is used by `preprocessParens`, `tryParseBackRef` and `parseParen`.
     */
    private parseCaptureName;
    /**
     * Parse capture name character.
     *
     * Unicode escape sequences are used as capture name character.
     */
    private parseCaptureNameChar;
    /** Parse digits. If parsing is failed, return `-1`. */
    private parseDigits;
    /** Parse hex digits. If parsing is failed, return `-1`. */
    private parseHexDigits;
    /** Try to parse `n` characters of hex digits.  If parsing is faield, return `-1`. */
    private tryParseHexDigitsN;
    /** Return the current character. */
    private current;
}
//# sourceMappingURL=parser.d.ts.map

export { BackRef, Capture, Char, CharSet, Class, ClassItem, ClassRange, Compiler, Disjunction, Dot, Element, EscapeClass, FlagSet, Group, LineBegin, LineEnd, LookAhead, LookBehind, Many, Match, NamedBackRef, NamedCapture, Node, OpCode, Optional, Parser, Pattern, Program, RegExpCompat, Repeat, Sequence, SimpleEscapeClass, Some, UnicodePropertyEscapeClass, UnicodePropertyValueEscapeClass, WordBoundary, codesToString, flagSetToString, nodeToString, patternToString };
